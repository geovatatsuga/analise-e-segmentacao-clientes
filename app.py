# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WWBYYUF6A_3Q-fW7tmEIhHmhEeAxNwtf
"""

import dash
from dash import dcc, html, Dash, Input, Output, State, dash_table, ctx
from dash.dependencies import Input, Output
import plotly.express as px
import plotly.graph_objs as go
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import plotly.io as pio
import dash_bootstrap_components as dbc
from plotly.subplots import make_subplots


# Importando dados
df = pd.read_csv('DADOS/dataset_for_analyst_assignment_20201120.csv')
df_final = pd.read_csv('DADOS/df_final_rfm.csv')

total_usuarios = len(df)
otimos_clientes = df_final['categoria_rfm'].value_counts().get('otimos_clientes', 0)
clientes_em_risco = df_final['categoria_rfm'].value_counts().get('em_risco', 0)
clientes_inativos = df_final['categoria_rfm'].value_counts().get('inativos', 0)


media_recencia = round(df_final['recencia'].mean(), 1)
media_frequencia = round(df_final['frequencia'].mean(), 1)
media_monetariedade = round(df_final['monetariedade'].mean(), 1)

total_clientes = len(df_final)

df_final['segmento'] = df_final['segmento'].astype(str)
df_final['cluster'] = df_final['cluster'].astype(str) # Garante que cluster √© string

# =================== TEMA E ESTILO ===================
pio.templates.default = "simple_white"
cores_segmento = {
    'adormecidos': '#636EFA', 'em_risco': '#EF553B', 'quase_inativos': '#AB63FA',
    'aliados_ouro': '#00CC96', 'nao_podemos_perder': '#FFA15A', 'parceiros_longa_data': '#19D3F3',
    'precisam_de_carinho': '#FF6692', 'quase_fieis': '#B6E880', 'promissores': '#FECB52',
    'recem_chegados': '#FF97FF',
    'default': '#CCCCCC' # Cor padr√£o para segmentos n√£o mapeados
}
cores_cluster = {
    "0": "#636EFA", "1": "#EF553B", "2": "#00CC96", "3": "#FFA15A"
}

# --- MUDAN√áA DE FONTE E √çCONES ---
external_styles = [
    dbc.themes.BOOTSTRAP,
    "https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap",
    "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
]

# =================== C√ÅLCULOS E AGRUPAMENTOS ===================
df_final['segmento'] = df_final['segmento'].astype(str)
df_group = df_final.groupby('segmento').agg(
    avg_recencia=('recencia', 'mean'),
    avg_frequencia=('frequencia', 'mean'),
    avg_monetariedade=('monetariedade', 'mean'),
    total_count=('user_id', 'count')
).reset_index()

# Certifica que o cluster √© tratado como string para agrupamento e mapeamento de cores
df_final['cluster'] = df_final['cluster'].astype(str)
df_group_cluster = df_final.groupby('cluster').agg(
    avg_recencia=('recencia', 'mean'),
    avg_frequencia=('frequencia', 'mean'),
    avg_monetariedade=('monetariedade', 'mean'),
    total_count=('user_id', 'count')
).reset_index()
# =================== GR√ÅFICOS ===================
default_font = dict(family='Poppins', size=13)

# Garantir que todas as cores de segmento existem no mapa ou usar default
cores_segmento_map = {seg: cores_segmento.get(seg, cores_segmento['default']) for seg in df_group['segmento'].unique()}

fig_bubble_rf_seg = px.scatter(
    df_group, x='avg_recencia', y='avg_frequencia', size='total_count',
    color='segmento', color_discrete_map=cores_segmento_map, size_max=60,
    labels={'avg_recencia': 'M√©dia Rec√™ncia (dias)', 'avg_frequencia': 'M√©dia Frequ√™ncia'},
    render_mode='webgl'
)
fig_bubble_rf_seg.update_traces(marker=dict(line=dict(width=1, color='DarkSlateGrey')))
fig_bubble_rf_seg.update_layout(
    plot_bgcolor='#fdfdfd', paper_bgcolor='#fafafa', margin=dict(t=50, l=10, r=10, b=10),
    title={
        'text': "Rec√™ncia x Frequ√™ncia (Segmentos)", 'x': 0.5, 'xanchor': 'center',
        'font': {'size': 20, 'color': '#333', 'family': 'Poppins'}
    },
    font=default_font,
    legend=dict(title=None, orientation="v", x=1.02, y=1, xanchor='left', bgcolor='rgba(0,0,0,0)')
)
fig_bubble_fm_seg = px.scatter(
    df_group, x='avg_frequencia', y='avg_monetariedade', size='total_count',
    color='segmento', color_discrete_map=cores_segmento_map, size_max=60,
    labels={'avg_frequencia': 'M√©dia Frequ√™ncia', 'avg_monetariedade': 'M√©dia Monetariedade (R$)'},
    render_mode='webgl'
)
fig_bubble_fm_seg.update_traces(marker=dict(line=dict(width=1, color='DarkSlateGrey')))
fig_bubble_fm_seg.update_layout(
    plot_bgcolor='#fdfdfd', paper_bgcolor='#fafafa', margin=dict(t=50, l=10, r=10, b=10),
    title={
        'text': "Monetariedade x Frequ√™ncia (Segmentos)", 'x': 0.5, 'xanchor': 'center',
        'font': {'size': 20, 'color': '#333', 'family': 'Poppins'}
    },
    font=default_font,
    legend=dict(title=None, orientation="v", x=1.02, y=1, xanchor='left', bgcolor='rgba(0,0,0,0)')
)

default_font_cluster = dict(family='Poppins', size=13, color='black')
fig_cluster_rf = px.scatter(
    df_group_cluster,
    x='avg_recencia', y='avg_frequencia', size='total_count',
    color='cluster', color_discrete_map=cores_cluster,
    labels={'avg_recencia': 'M√©dia Rec√™ncia (dias)', 'avg_frequencia': 'M√©dia Frequ√™ncia'},
    size_max=60, render_mode='webgl'
)
fig_cluster_rf.update_traces(marker=dict(symbol='circle', line=dict(width=1, color='black')))
fig_cluster_rf.update_layout(
    title={'text': "Rec√™ncia x Frequ√™ncia por Cluster", 'x': 0.5, 'xanchor': 'center',
           'font': {'size': 20, 'color': 'black', 'family': 'Poppins'}},
    font=default_font_cluster, plot_bgcolor='#ffffff', paper_bgcolor='#ffffff', legend=dict(title=None)
)
fig_cluster_fm = px.scatter(
    df_group_cluster,
    x='avg_frequencia', y='avg_monetariedade', size='total_count',
    color='cluster', color_discrete_map=cores_cluster,
    labels={'avg_frequencia': 'M√©dia Frequ√™ncia', 'avg_monetariedade': 'M√©dia Monetariedade (R$)'},
    size_max=60, render_mode='webgl'
)
fig_cluster_fm.update_traces(marker=dict(symbol='circle', line=dict(width=1, color='black')))
fig_cluster_fm.update_layout(
    title={'text': "Monetariedade x Frequ√™ncia por Cluster", 'x': 0.5, 'xanchor': 'center',
           'font': {'size': 20, 'color': 'black', 'family': 'Poppins'}},
    font=default_font_cluster, plot_bgcolor='#ffffff', paper_bgcolor='#ffffff', legend=dict(title=None)
)

# =================== CARDS (Com Est√©tica Melhorada) ===================
def criar_card(titulo, valor, emoji, cor="#ffffff"):
    card_title = f"{emoji} {titulo}" if emoji else titulo
    # Formatando o valor para inteiro, se poss√≠vel
    try:
        valor_formatado = f"{int(valor):,}".replace(",", ".")
    except (ValueError, TypeError):
        valor_formatado = str(valor) # Mant√©m como string se n√£o for num√©rico

    return dbc.Card(
        dbc.CardBody([
            html.H5(card_title, className="card-title", style={
                'fontFamily': 'Poppins',
                'fontWeight': '600',
                'fontSize': '0.95rem',
                'color': '#555'
            }),
            html.H2(valor_formatado, className="card-text", style={
                'fontFamily': 'Poppins',
                'fontWeight': '700',
                'fontSize': '2rem',
                'color': '#222'
            })
        ]),
        className="mb-2 text-center shadow-sm p-3 rounded h-100",
        style={"background": f"linear-gradient(to right, {cor}, #ffffff)", 'border': 'none'}
    )

def card_media(indicador, letra, cor_letra, valor):
    formatted_valor = f"{valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".") # Formato brasileiro
    return dbc.Card(
        dbc.CardBody([
            html.Div([
                html.Div(letra, style={
                    "fontSize": "2.5em", "color": cor_letra, "marginRight": "15px",
                    "border": f"2px solid {cor_letra}", "borderRadius": "50%",
                    "width": "60px", "height": "60px", "display": "flex",
                    "alignItems": "center", "justifyContent": "center", "flexShrink": 0,
                    'fontWeight': '700', 'fontFamily': 'Poppins'
                }),
                html.Div([
                    html.H4(f"{indicador}", className="card-title mb-1", style={
                        'fontFamily': 'Poppins',
                        'fontWeight': '600',
                        'fontSize': '1rem',
                        'color': '#444'
                    }),
                    html.H2(formatted_valor, className="card-text", style={
                        'fontFamily': 'Poppins',
                        'fontWeight': '700',
                        'fontSize': '1.8rem',
                        'color': '#222'
                    })
                ], style={"textAlign": "left", "margin": "auto 0"}) # Alinhado √† esquerda
            ], style={"display": "flex", "alignItems": "center", "justifyContent": "flex-start"}) # Conte√∫do alinhado √† esquerda
        ]),
        className="mb-2 shadow-sm p-3 rounded h-100",
        style={"backgroundColor": "#f8f9fa", 'border': 'none'}
    )

# =================== DEFINI√á√ÉO DOS CARDS ===================
card_total_usuarios = criar_card("Total de Usu√°rios", total_usuarios, "", "#e3f2fd")
card_total_clientes = criar_card("Total de Clientes", total_clientes, "", "#e8f5e9")
card_otimos_clientes = criar_card("√ìtimos Clientes", otimos_clientes, "üåü", "#fff8e1")
card_clientes_em_risco = criar_card("Clientes em Risco", clientes_em_risco, "‚ö†Ô∏è", "#ffebee")
card_clientes_inativos = criar_card("Clientes Inativos", clientes_inativos, "‚òÅÔ∏è", "#ede7f6")
card_media_recencia = card_media("Rec√™ncia M√©dia", "R", "#dc3545", media_recencia)
card_media_frequencia = card_media("Frequ√™ncia M√©dia", "F", "#0d6efd", media_frequencia)
card_media_monetariedade = card_media("Monetariedade M√©dia", "M", "#198754", media_monetariedade)

# =================== TABELA EXPLICATIVA CLUSTER (NOVO) ===================
tabela_cluster_explicativa_data = [
    {'Cluster': '0', '% Clientes': '29.1%', 'Top Segmentos': 'Adormecidos (91.9%), Em Risco (4.7%), Quase Inativos (3.4%)', 'Perfil': 'Clientes com 1 compra, gasto baixo, inativos h√° muito tempo.'},
    {'Cluster': '1', '% Clientes': '33.4%', 'Top Segmentos': 'Parceiros Longa Data (49.0%), Aliados Ouro (46.6%), Quase Fi√©is (2.8%)', 'Perfil': 'Clientes muito frequentes, recentes e de alto valor. Valiosos e ativos.'},
    {'Cluster': '2', '% Clientes': '19.8%', 'Top Segmentos': 'Quase Fi√©is (44.4%), Quase Inativos (24.0%), Precisam de Carinho (13.7%)', 'Perfil': 'Gasto moderado, baixa frequ√™ncia, inativos h√° algum tempo. Potencial de lealdade.'},
    {'Cluster': '3', '% Clientes': '17.7%', 'Top Segmentos': 'Em Risco (49.8%), Precisam de Carinho (17.7%), Parceiros Longa Data (15.8%)', 'Perfil': 'Grandes compras passadas, inativos h√° tempo, frequ√™ncia diminuiu. Risco de churn.'}
]

tabela_cluster_explicativa_columns = [
    {"name": "Cluster", "id": "Cluster"},
    {"name": "% Clientes", "id": "% Clientes"},
    {"name": "Principais Segmentos RFM", "id": "Top Segmentos"}, # Nome da coluna atualizado
    {"name": "Perfil Resumido", "id": "Perfil"} # Nome da coluna atualizado
]

tabela_explicativa_cluster = dash_table.DataTable(
    id='tabela-explicativa-cluster',
    columns=tabela_cluster_explicativa_columns,
    data=tabela_cluster_explicativa_data,
    style_table={'overflowX': 'auto', 'marginBottom': '30px', 'border': '1px solid #ddd', 'borderRadius': '5px'},
    style_cell={
        'textAlign': 'left', 'padding': '10px',
        'fontFamily': 'Poppins', 'fontSize': '0.85rem',
        'border': '1px solid #eee',
        'whiteSpace': 'normal', 'height': 'auto', # Permite quebra de linha
        'minWidth': '100px', 'width': 'auto', 'maxWidth': '350px' # Ajuste de largura
    },
    style_header={
        'backgroundColor': '#f0f2f5', 'fontWeight': 'bold',
        'fontFamily': 'Poppins', 'fontSize': '0.9rem',
        'border': '1px solid #ddd',
        'color': '#333'
    },
    style_data_conditional=[
        {'if': {'row_index': 'odd'}, 'backgroundColor': '#fdfdfd'},
        {'if': {'column_id': 'Cluster'}, 'textAlign': 'center', 'fontWeight': 'bold'}, # Centraliza Cluster ID
        {'if': {'column_id': '% Clientes'}, 'textAlign': 'center'}, # Centraliza %
    ],
    style_as_list_view=True, # Remove linhas verticais entre c√©lulas de dados
)

# =================== APP DASH ===================
app = dash.Dash(__name__, external_stylesheets=external_styles, suppress_callback_exceptions=True)
app.title = "Segmenta√ß√£o e Cluster RFM"

# ========= LAYOUT FIXO (CABE√áALHO E KPIS) =========
header_layout = dbc.Container([
    # T√≠tulo principal
    dbc.Row(
        dbc.Col(html.H1("An√°lise RFM", className="text-center my-4", style={
            'fontFamily': 'Poppins',
            'fontWeight': '700',
            'color': '#333',
            'letterSpacing': '1px'
        }))
    ),
    # Cards
    dbc.Row([
        dbc.Col(card_total_usuarios, md=2),
        dbc.Col(card_total_clientes, md=2),
        dbc.Col(card_otimos_clientes, md=2),
        dbc.Col(card_clientes_em_risco, md=3),
        dbc.Col(card_clientes_inativos, md=3)
    ], className="mb-4 g-4", align="stretch"),
    dbc.Row([
        dbc.Col(card_media_recencia, md=4),
        dbc.Col(card_media_frequencia, md=4),
        dbc.Col(card_media_monetariedade, md=4)
    ], className="mb-4 g-4", align="stretch"),
], fluid=True, style={"background": "linear-gradient(to bottom, #f0f2f5, #ffffff)", "padding": "20px"})

# ========= LAYOUT DIN√ÇMICO (SEGMENTOS OU CLUSTERS) =========
# Define os layouts como vari√°veis para reutiliza√ß√£o
segmentos_layout = html.Div([
    dbc.Row([
        dbc.Col(dcc.Graph(id='seg-fig-bubble-rf', figure=fig_bubble_rf_seg), md=6),
        dbc.Col(dcc.Graph(id='seg-fig-bubble-fm', figure=fig_bubble_fm_seg), md=6)
    ], className="mb-4"),
    # Dropdown, bot√£o de download e tabela
    dbc.Row([
        dbc.Col([
            html.H4("Clientes por Segmento", className="text-center mb-3", style={
                'fontFamily': 'Poppins', 'fontWeight': '600'
            }),
            dcc.Dropdown(
                id='seg-segmento-dropdown',
                options=[{'label': seg.replace("_", " ").title(), 'value': seg} for seg in sorted(df_final['segmento'].unique())],
                value=sorted(df_final['segmento'].unique())[0] if df_final['segmento'].nunique() > 0 else None, # Valor inicial seguro
                clearable=False,
                placeholder="Selecione um segmento...",
                style={'marginBottom': '20px', 'fontFamily': 'Poppins'}
            ),
            html.Div([
                html.Button([
                    html.I(className="bi bi-download me-2"), "Baixar CSV"
                ], id="seg-btn-download-csv", n_clicks=0, className="btn btn-outline-primary mb-3", style={
                    'fontFamily': 'Poppins', 'fontWeight': '600'
                }),
                dcc.Download(id="seg-download-clientes-csv")
            ], style={'textAlign': 'left'}),
            dash_table.DataTable(
                id='seg-tabela-clientes-segmento',
                # Definir colunas aqui ajuda a peg√°-las nos callbacks
                columns=[{"name": col.replace("_", " ").title(), "id": col} for col in df_final.columns if col not in ['cluster']], # Oculta cluster aqui
                page_size=10,
                page_current=0,
                page_action='native',
                filter_action='none',
                sort_action='native',
                style_table={'overflowX': 'auto', 'margin': 'auto', 'width': '100%'},
                style_cell={
                    'textAlign': 'center', 'minWidth': '100px', 'padding': '10px',
                    'border': '1px solid #dee2e6',
                    'fontFamily': 'Poppins',
                    'whiteSpace': 'normal', 'height': 'auto'
                },
                style_data_conditional=[
                    {'if': {'row_index': 'odd'}, 'backgroundColor': '#f8f9fa'},
                    {'if': {'column_id': 'segmento'}, 'fontWeight': 'bold', 'color': '#007bff'}
                ],
                style_header={
                    'backgroundColor': '#e9ecef', 'fontWeight': 'bold',
                    'fontFamily': 'Poppins',
                    'border': '1px solid #dee2e6'
                },
                style_as_list_view=True
            )
        ], width=12, className="mx-auto")
    ], className="my-4")
])

clusters_layout = html.Div([
    # T√≠tulo para a tabela explicativa (NOVO)
    html.H4("Entendendo os Clusters", className="text-center mt-4 mb-3", style={ # Adicionado mt-4
         'fontFamily': 'Poppins', 'fontWeight': '600', 'color': '#444'
    }),
    # Tabela Explicativa de Clusters (NOVO)
    dbc.Row(
        dbc.Col(tabela_explicativa_cluster, width=12), # Largura 12 para ocupar a linha
        className="mb-4" # Espa√ßamento abaixo da tabela
    ),
    # Gr√°ficos de Cluster (EXISTENTES)
    dbc.Row([
        dbc.Col(dcc.Graph(id='clu-fig-cluster-rf', figure=fig_cluster_rf), md=6),
        dbc.Col(dcc.Graph(id='clu-fig-cluster-fm', figure=fig_cluster_fm), md=6)
    ]),
    # Dropdown, bot√£o de download e tabela de dados (EXISTENTES)
    dbc.Row([
        dbc.Col([
            html.H4("Clientes por Cluster", className="text-center mb-3 mt-4", style={ # Adicionado mt-4
                'fontFamily': 'Poppins', 'fontWeight': '600'
            }),
            dcc.Dropdown(
                id='clu-cluster-dropdown',
                options=[{'label': f'Cluster {str(c)}', 'value': str(c)} for c in sorted(df_final['cluster'].unique())],
                value=sorted(df_final['cluster'].unique())[0] if df_final['cluster'].nunique() > 0 else None, # Valor inicial seguro
                clearable=False,
                placeholder="Selecione um cluster...",
                style={'marginBottom': '20px', 'fontFamily': 'Poppins'}
            ),
            html.Div([
                html.Button([
                    html.I(className="bi bi-download me-2"), "Baixar CSV"
                ], id="clu-btn-download-cluster-csv", n_clicks=0,
                    className="btn btn-outline-success mb-3", style={'fontFamily': 'Poppins'}), # Mudou cor do bot√£o
                dcc.Download(id="clu-download-clientes-cluster-csv")
            ], style={'textAlign': 'left'}),
            dash_table.DataTable(
                id='clu-tabela-clientes-cluster',
                # Definir colunas aqui ajuda a peg√°-las nos callbacks
                columns=[{"name": col.replace("_", " ").title(), "id": col} for col in df_final.columns if col not in ['segmento']], # Oculta segmento aqui
                page_size=10,
                page_current=0,
                page_action='native',
                filter_action='none',
                sort_action='native',
                style_table={'overflowX': 'auto', 'margin': 'auto', 'width': '100%'},
                style_cell={
                    'textAlign': 'center', 'minWidth': '100px', 'padding': '10px',
                    'border': '1px solid #dee2e6', 'fontFamily': 'Poppins',
                    'whiteSpace': 'normal', 'height': 'auto'
                },
                style_data_conditional=[
                    {'if': {'row_index': 'odd'}, 'backgroundColor': '#f8f9fa'},
                    # Colorir baseado no cluster usando o mapa de cores
                    *[ {'if': {'filter_query': f'{{cluster}} = "{clust}"', 'column_id': 'cluster'},
                       'backgroundColor': cores_cluster.get(str(clust), '#CCCCCC'), # Usa a cor do cluster
                       'color': 'white', # Texto branco para melhor contraste
                       'fontWeight': 'bold'}
                      for clust in cores_cluster]
                ],
                style_header={
                    'backgroundColor': '#f1f1f1', 'fontWeight': 'bold',
                    'fontFamily': 'Poppins', 'color': '#333',
                    'border': '1px solid #dee2e6'
                },
                style_as_list_view=True
            )
        ], width=12, className="mx-auto")
    ], className="my-4")
])

# ========= LAYOUT PRINCIPAL =========
app.layout = dbc.Container([
    header_layout,
    dbc.Row(
        dbc.Col(
            # Atualizado para usar dbc.ButtonGroup para melhor apar√™ncia
            dbc.ButtonGroup([
                dbc.Button("Mostrar Segmentos", id="show-segmentos-button", n_clicks=0, color="primary", outline=True, className="me-1"),
                dbc.Button("Mostrar Clusters", id="show-clusters-button", n_clicks=0, color="success", outline=True),
            ]),
            width={"size": "auto"}, # Ajusta a largura ao conte√∫do
            className="d-flex justify-content-center mb-3" # Centraliza os bot√µes
        )
    ),
    # Elemento oculto para armazenar o estado da visualiza√ß√£o (segmentos ou clusters)
    dcc.Store(id='view-mode-store', data='segmentos'),
    # Conte√∫do din√¢mico ser√° carregado aqui pelos callbacks
    html.Div(id='dynamic-content')
], fluid=True, style={'paddingBottom': '50px'}) # Adiciona padding inferior

# =================== CALLBACKS ===================

# Callback para alternar entre os layouts e atualizar o bot√£o ativo
@app.callback(
    Output('dynamic-content', 'children', allow_duplicate=True), # Sa√≠da duplicada
    Output('show-segmentos-button', 'outline', allow_duplicate=True), # Sa√≠da duplicada
    Output('show-clusters-button', 'outline', allow_duplicate=True), # Sa√≠da duplicada
    Output('view-mode-store', 'data'),
    Input('show-segmentos-button', 'n_clicks'),
    Input('show-clusters-button', 'n_clicks'),
    State('view-mode-store', 'data'),
    prevent_initial_call=True # IMPEDE execu√ß√£o inicial por este callback
)
def toggle_content_and_buttons(seg_clicks, clu_clicks, current_mode):
    button_id = ctx.triggered_id
    if button_id == 'show-clusters-button' and current_mode != 'clusters':
        return clusters_layout, True, False, 'clusters' # Mostra Clusters, bot√£o Cluster ativo
    elif button_id == 'show-segmentos-button' and current_mode != 'segmentos':
        return segmentos_layout, False, True, 'segmentos' # Mostra Segmentos, bot√£o Segmento ativo

    # Se clicar no bot√£o j√° ativo ou nenhum bot√£o relevante foi clicado, retorna NoUpdate para evitar re-render desnecess√°rio
    # Ou, se preferir sempre retornar o estado atual:
    if current_mode == 'clusters':
         return clusters_layout, True, False, 'clusters'
    else: # current_mode == 'segmentos'
         return segmentos_layout, False, True, 'segmentos'
    # return dash.no_update, dash.no_update, dash.no_update, dash.no_update


# Callback para carregar o layout inicial (AGORA COM prevent_initial_call='initial_duplicate')
@app.callback(
    Output('dynamic-content', 'children', allow_duplicate=True), # Sa√≠da duplicada
    Output('show-segmentos-button', 'outline', allow_duplicate=True), # Sa√≠da duplicada
    Output('show-clusters-button', 'outline', allow_duplicate=True), # Sa√≠da duplicada
    Input('view-mode-store', 'data'), # Dispara quando o app carrega (ou quando o store muda)
    prevent_initial_call='initial_duplicate' # <<< CORRE√á√ÉO APLICADA AQUI
)
def load_initial_content(initial_mode):
     print(f"Loading initial content based on mode: {initial_mode}") # Debug
     if initial_mode == 'clusters':
        return clusters_layout, True, False
     else: # Default to segmentos
        return segmentos_layout, False, True

# --- Callbacks para as tabelas de dados e downloads (sem altera√ß√µes necess√°rias aqui) ---

# Callback para atualizar tabela de segmentos
@app.callback(
    Output('seg-tabela-clientes-segmento', 'data'),
    Input('seg-segmento-dropdown', 'value'),
    # Adiciona State para pegar colunas da tabela
    State('seg-tabela-clientes-segmento', 'columns')
)
def atualizar_tabela_segmento(segmento_selecionado, table_columns):
    if not segmento_selecionado:
        # Se n√£o houver sele√ß√£o, tenta usar o primeiro segmento como padr√£o
        segmento_selecionado = sorted(df_final['segmento'].unique())[0] if df_final['segmento'].nunique() > 0 else None
        if not segmento_selecionado:
            return [] # Retorna vazio se n√£o houver segmentos

    df_filtrado = df_final[df_final['segmento'] == segmento_selecionado]
    # Pega os IDs das colunas definidas na tabela
    cols_to_show = [col['id'] for col in table_columns]
    return df_filtrado[cols_to_show].to_dict('records')

# Callback para download CSV de segmentos
@app.callback(
    Output("seg-download-clientes-csv", "data"),
    Input("seg-btn-download-csv", "n_clicks"),
    State("seg-segmento-dropdown", "value"), # Usa State
    State('seg-tabela-clientes-segmento', 'columns'), # Pega colunas da tabela
    prevent_initial_call=True
)
def baixar_csv_segmento(n_clicks, segmento_selecionado, table_columns):
    if n_clicks > 0 and segmento_selecionado:
        df_filtrado = df_final[df_final['segmento'] == segmento_selecionado]
        # Usa as colunas vis√≠veis na tabela para o CSV
        cols_to_show = [col['id'] for col in table_columns]
        return dcc.send_data_frame(df_filtrado[cols_to_show].to_csv, f"clientes_{segmento_selecionado}.csv", index=False, encoding='utf-8-sig') # Adiciona encoding

# Callback para atualizar tabela de clusters
@app.callback(
    Output('clu-tabela-clientes-cluster', 'data'),
    Input('clu-cluster-dropdown', 'value'),
    # Adiciona State para pegar colunas da tabela
    State('clu-tabela-clientes-cluster', 'columns')
)
def atualizar_tabela_cluster(cluster_selecionado, table_columns):
    if not cluster_selecionado:
        # Se n√£o houver sele√ß√£o, tenta usar o primeiro cluster como padr√£o
        cluster_selecionado = sorted(df_final['cluster'].unique())[0] if df_final['cluster'].nunique() > 0 else None
        if not cluster_selecionado:
             return [] # Retorna vazio se n√£o houver clusters

    # Garante que estamos comparando strings
    df_filtrado = df_final[df_final['cluster'] == str(cluster_selecionado)]
    # Pega os IDs das colunas definidas na tabela
    cols_to_show = [col['id'] for col in table_columns]
    return df_filtrado[cols_to_show].to_dict('records')

# Callback para download CSV de clusters
@app.callback(
    Output("clu-download-clientes-cluster-csv", "data"),
    Input("clu-btn-download-cluster-csv", "n_clicks"),
    State("clu-cluster-dropdown", "value"), # Usa State
    State('clu-tabela-clientes-cluster', 'columns'), # Pega colunas da tabela
    prevent_initial_call=True
)
def baixar_csv_cluster(n_clicks, cluster_selecionado, table_columns):
    if n_clicks > 0 and cluster_selecionado:
        # Garante que estamos comparando strings
        df_filtrado = df_final[df_final['cluster'] == str(cluster_selecionado)]
        # Usa as colunas vis√≠veis na tabela para o CSV
        cols_to_show = [col['id'] for col in table_columns]
        return dcc.send_data_frame(df_filtrado[cols_to_show].to_csv, f"clientes_cluster_{cluster_selecionado}.csv", index=False, encoding='utf-8-sig') # Adiciona encoding

# =================== RUN SERVER ===================
if __name__ == '__main__':
    app.run(debug=True)